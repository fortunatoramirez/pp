# **Práctica: Implementación de Parallax Scrolling utilizando Pygame**

## **1. Introducción**

El objetivo de esta práctica es que el estudiante comprenda y aplique el concepto de *parallax scrolling*, una técnica empleada en videojuegos de plataformas para simular profundidad mediante el desplazamiento de varias capas de fondo a diferentes velocidades. Esta práctica utiliza los elementos gráficos del paquete **"game_background_1"**, disponible para uso libre y descargable desde el repositorio oficial de Kenney.

En esta actividad se trabajará con las capas que componen el fondo, tales como el cielo, nubes, rocas y elementos adicionales, para generar un desplazamiento continuo e infinito. Se explicará detalladamente la lógica empleada para cargar las imágenes, organizarlas en capas, asignarles velocidades relativas y programar el desplazamiento horizontal continuo.

---

## **2. Enlace del material gráfico utilizado**

El recurso utilizado proviene del paquete oficial:

**game_backgrounds (Kenney):**
[https://free-game-assets.itch.io/free-horizontal-game-backgrounds](https://free-game-assets.itch.io/free-horizontal-game-backgrounds)

---

## **3. Organización del proyecto**

Se recomienda organizar la estructura del proyecto de la siguiente manera:

```
practica_parallax/
│── main.py
│── assets/
      └── game_background_1/
            └── layers/
                sky.png
                clouds_1.png
                clouds_2.png
                clouds_3.png
                clouds_4.png
                rocks_1.png
                rocks_2.png
```

La carpeta `layers` contiene las imágenes que se utilizarán de forma independiente para generar el efecto de desplazamiento con profundidad.

---

## **4. Teoría esencial sobre parallax scrolling**

El *parallax scrolling* es una técnica de animación donde las capas más cercanas al observador se desplazan más rápido que las capas lejanas. Esto genera una ilusión de profundidad tridimensional dentro de un entorno 2D.

* Capas traseras → se desplazan lentamente.
* Capas intermedias → velocidad moderada.
* Capas delanteras → se desplazan más rápido.

El efecto se programa realizando dos acciones fundamentales:

1. **Movimiento horizontal continuo de cada capa**, con una velocidad distinta.
2. **Dibujo duplicado de cada capa** (una imagen seguida de otra) para crear un desplazamiento infinito sin cortes.

---

## **5. Desarrollo de la práctica**

### **Bloque 1. Carga y visualización estática de capas**

**Descripción:**
En este bloque se cargan las imágenes correspondientes a cada capa del fondo. El propósito es familiarizarse con las capas del material gráfico y verificar que se dibujan correctamente en pantalla, sin movimiento. Esto sirve como base para los siguientes bloques.

**Código del Bloque 1:**

```python
import pygame
pygame.init()

# Pantalla
ANCHO, ALTO = 1280, 720
pantalla = pygame.display.set_mode((ANCHO, ALTO))
pygame.display.set_caption("Parallax — Bloque 1")

# Cargar capas (orden desde el fondo hacia adelante)
capas = [
    pygame.image.load("assets/game_background_1/layers/sky.png"),
    pygame.image.load("assets/game_background_1/layers/clouds_1.png"),
    pygame.image.load("assets/game_background_1/layers/clouds_2.png"),
    pygame.image.load("assets/game_background_1/layers/clouds_3.png"),
    pygame.image.load("assets/game_background_1/layers/clouds_4.png"),
    pygame.image.load("assets/game_background_1/layers/rocks_1.png"),
    pygame.image.load("assets/game_background_1/layers/rocks_2.png")
]

reloj = pygame.time.Clock()
ejecutando = True

while ejecutando:
    for event in pygame.event.get():
        if event.type == pygame.QUIT:
            ejecutando = False

    # Dibujar todas las capas sin movimiento
    for capa in capas:
        pantalla.blit(capa, (0, 0))

    pygame.display.update()
    reloj.tick(60)

pygame.quit()
```

---

### **Bloque 2. Implementación del desplazamiento con efecto parallax**

**Descripción:**
En este bloque se agregan velocidades diferentes a cada capa y se implementa el movimiento horizontal. Para evitar cortes en el desplazamiento, cada capa se dibuja dos veces: una en su posición actual y otra inmediatamente después de su ancho. Cuando una imagen termina de desplazarse completamente a la izquierda, se reinicia su posición hacia la derecha, creando un bucle continuo.

**Código del Bloque 2:**

```python
import pygame
pygame.init()

ANCHO, ALTO = 1280, 720
pantalla = pygame.display.set_mode((ANCHO, ALTO))
pygame.display.set_caption("Parallax — Bloque 2")

# Lista con nombres de capas
nombres_capas = [
    "sky",
    "clouds_1",
    "clouds_2",
    "clouds_3",
    "clouds_4",
    "rocks_1",
    "rocks_2"
]

# Carga de imágenes
capas = [pygame.image.load(f"assets/game_background_1/layers/{n}.png") for n in nombres_capas]

# Velocidades relativas (capas traseras → más lento; delanteras → más rápido)
vel = [0.1, 0.3, 0.5, 0.8, 1.0, 2.0, 3.0]

# Posiciones iniciales duplicadas
x1 = [0 for _ in capas]
x2 = [capa.get_width() for capa in capas]

reloj = pygame.time.Clock()
ejecutando = True

while ejecutando:
    for event in pygame.event.get():
        if event.type == pygame.QUIT:
            ejecutando = False

    pantalla.fill((0,0,0))

    for i, capa in enumerate(capas):
        x1[i] -= vel[i]
        x2[i] -= vel[i]

        ancho = capas[i].get_width()

        # Reinicio cuando una imagen termina su recorrido
        if x1[i] <= -ancho:
            x1[i] = ancho
        if x2[i] <= -ancho:
            x2[i] = ancho

        # Dibujar doble capa para efecto continuo
        pantalla.blit(capa, (x1[i], 0))
        pantalla.blit(capa, (x2[i], 0))

    pygame.display.update()
    reloj.tick(60)

pygame.quit()
```

---

## **6. Código final integrado**

A continuación se presenta el código completo que combina los bloques anteriores en una sola versión funcional.

```python
import pygame
pygame.init()

ANCHO, ALTO = 1280, 720
pantalla = pygame.display.set_mode((ANCHO, ALTO))
pygame.display.set_caption("Práctica Parallax — game_background_1")

# Lista de capas en orden de profundidad
nombres_capas = [
    "sky",
    "clouds_1",
    "clouds_2",
    "clouds_3",
    "clouds_4",
    "rocks_1",
    "rocks_2"
]

# Carga de imágenes
capas = [pygame.image.load(f"assets/game_background_1/layers/{n}.png") for n in nombres_capas]

# Velocidades relativas (más cercano → más rápido)
vel = [0.1, 0.3, 0.5, 0.8, 1.0, 2.0, 3.0]

# Posiciones X iniciales para movimiento continuo
x1 = [0 for _ in capas]
x2 = [capa.get_width() for capa in capas]

reloj = pygame.time.Clock()
ejecutando = True

while ejecutando:
    for event in pygame.event.get():
        if event.type == pygame.QUIT:
            ejecutando = False

    pantalla.fill((0,0,0))

    for i, capa in enumerate(capas):
        x1[i] -= vel[i]
        x2[i] -= vel[i]

        ancho = capas[i].get_width()

        # Reinicio de posición al salir de la pantalla
        if x1[i] <= -ancho:
            x1[i] = ancho
        if x2[i] <= -ancho:
            x2[i] = ancho

        pantalla.blit(capa, (x1[i], 0))
        pantalla.blit(capa, (x2[i], 0))

    pygame.display.update()
    reloj.tick(60)

pygame.quit()
```

---

## **7. Actividad de comprobación**

El estudiante deberá responder:

1. ¿Qué diferencia existe entre la velocidad asignada a las capas del fondo y las capas delanteras?
2. ¿Qué propósito tiene dibujar dos copias de cada capa en la pantalla?
3. ¿Qué ocurriría si no se reiniciara la posición de una capa al salir del área visible?
4. Modifique la práctica para invertir la dirección del desplazamiento y describa los cambios realizados.

---
---
---

# **Agregando un personaje animado**

En esta sección se ampliará la práctica incorporando un personaje animado dentro del escenario con *parallax scrolling*. El objetivo es que el estudiante aprenda a integrar un sprite sheet complejo, extraer sus regiones, generar una animación fluida y finalmente permitir el control del personaje mediante el teclado.
Esto permitirá combinar varias habilidades desarrolladas previamente: manejo de imágenes, animación cuadro por cuadro y control interactivo del usuario.

---

## **1. Recurso gráfico del personaje**

El personaje utilizado será un dragón proveniente del repositorio libre:

**Dragon Sprite Sheet (opengameart.org):**
[https://opengameart.org/node/83655](https://opengameart.org/node/83655)

El recurso consiste en un sprite sheet donde cada acción se compone de varios fotogramas en una sola imagen. En este ejercicio se utilizarán únicamente los fotogramas correspondientes a la animación de vuelo.

---

## **2. Organización del recurso dentro del proyecto**

Se recomienda agregar el sprite sheet del dragón dentro de la siguiente estructura:

```
practica_parallax/
│── main.py
│── assets/
      ├── game_background_1/
      │      └── layers/    (capas del parallax)
      └── dragon/
             └── dragon.png
```

El archivo `dragon.png` debe ser el sprite sheet original sin modificaciones.

---

## **3. Consideraciones teóricas sobre el uso de sprite sheets**

Un sprite sheet es una sola imagen que contiene múltiples fotogramas uniformemente distribuidos. Para animar al dragón se requiere:

1. Identificar el número de filas y columnas.
2. Determinar el ancho y la altura de cada fotograma.
3. Recortar cada fotograma mediante coordenadas regulares.
4. Almacenar los fotogramas en una lista para reproducirlos secuencialmente.
5. Controlar la velocidad de animación de manera independiente de la lógica del juego.

Estas técnicas permiten generar animaciones fluidas sin utilizar archivos separados.

---

## **4. Preparación del sprite sheet y extracción de fotogramas**

En esta sección se mostrará cómo cargar el sprite sheet, calcular sus dimensiones y extraer cada fotograma correspondiente al vuelo del dragón.

### Código base para cargar y recortar el sprite sheet

```python
# Carga del sprite sheet
dragon_sheet = pygame.image.load("assets/dragon/dragon.png").convert_alpha()

# Según el recurso de OpenGameArt: 4 filas y 3 columnas
rows = 4
cols = 3

sheet_width = dragon_sheet.get_width()
sheet_height = dragon_sheet.get_height()

frame_width = sheet_width // cols
frame_height = sheet_height // rows

# Función general para extraer frames
def get_frame(r, c):
    rect = pygame.Rect(c * frame_width, r * frame_height, frame_width, frame_height)
    frame = dragon_sheet.subsurface(rect)
    return frame
```

---

## **5. Selección de fotogramas de vuelo**

Para esta práctica se seleccionarán únicamente los fotogramas correspondientes al vuelo del dragón.
Dado que el recurso puede contener poses adicionales, se trabaja específicamente con las filas destinadas a animación aérea.

### Código para seleccionar los fotogramas del vuelo

```python
# Fotogramas de vuelo (ajustar según el sprite elegido)
# Para este recurso usaremos las filas 0 y 2 como ejemplo
dragon_frames = []

for c in range(cols):
    dragon_frames.append(get_frame(0, c))

for c in range(cols):
    dragon_frames.append(get_frame(2, c))

# Velocidad de animación
dragon_index = 0
dragon_fps = 10
```

---

## **6. Animación del dragón dentro del escenario con parallax**

Ahora se integrará la animación del dragón dentro del escenario ya generado en la práctica principal.
El dragón será dibujado sobre todas las capas para simular que vuela frente al paisaje.

### Código para animarlo sobre el parallax

```python
# Posición inicial del dragón
dragon_x = 200
dragon_y = 300

# Reloj interno de animación
dragon_timer = pygame.time.get_ticks()
```

Dentro del bucle principal de dibujo:

```python
# Animación del dragón
if pygame.time.get_ticks() - dragon_timer > 1000 // dragon_fps:
    dragon_timer = pygame.time.get_ticks()
    dragon_index = (dragon_index + 1) % len(dragon_frames)

frame_actual = dragon_frames[dragon_index]
pantalla.blit(frame_actual, (dragon_x, dragon_y))
```

---

## **7. Control del dragón mediante el teclado**

En esta etapa se añadirá control básico utilizando el teclado, de modo que el estudiante pueda mover libremente al personaje a través del escenario.

### Código para capturar el teclado y mover al dragón

```python
teclas = pygame.key.get_pressed()

velocidad_dragon = 5

if teclas[pygame.K_UP]:
    dragon_y -= velocidad_dragon
if teclas[pygame.K_DOWN]:
    dragon_y += velocidad_dragon
if teclas[pygame.K_LEFT]:
    dragon_x -= velocidad_dragon
if teclas[pygame.K_RIGHT]:
    dragon_x += velocidad_dragon
```

Esto permite al alumno experimentar con cinemática básica y ajustar el comportamiento del personaje.

---

## **8. Código completo integrado del dragón dentro del escenario**

Este fragmento se inserta **después del código principal de parallax** y antes del `pygame.display.update()`.
Representa la integración completa del personaje animado y totalmente funcional:

```python
# -----------------------
# Animación del dragón
# -----------------------

# Actualizar animación del vuelo
if pygame.time.get_ticks() - dragon_timer > 1000 // dragon_fps:
    dragon_timer = pygame.time.get_ticks()
    dragon_index = (dragon_index + 1) % len(dragon_frames)

frame_actual = dragon_frames[dragon_index]

# Controles
teclas = pygame.key.get_pressed()
velocidad_dragon = 5

if teclas[pygame.K_UP]:
    dragon_y -= velocidad_dragon
if teclas[pygame.K_DOWN]:
    dragon_y += velocidad_dragon
if teclas[pygame.K_LEFT]:
    dragon_x -= velocidad_dragon
if teclas[pygame.K_RIGHT]:
    dragon_x += velocidad_dragon

# Dibujar el dragón
pantalla.blit(frame_actual, (dragon_x, dragon_y))
```

---

## **9. Actividad de comprobación adicional**

El estudiante deberá:

1. Explicar cómo se calcula la posición de cada fotograma dentro del sprite sheet.
2. Describir por qué la animación del dragón funciona de forma independiente del movimiento del escenario.
3. Ajustar la velocidad del vuelo para que parezca más realista.
4. Modificar el código para que el dragón pueda aumentar o disminuir su tamaño mediante escalado (`pygame.transform.scale`).
5. Diseñar un límite que impida que el dragón salga completamente de la pantalla.

---
---
---

# **Control direccional del personaje y animación según la orientación**

---

En esta sección se implementará un sistema completo de dirección del personaje. El objetivo es que el dragón modifique su animación dependiendo de la dirección en la que se desplace: hacia arriba, abajo, izquierda o derecha.
Dado que el sprite sheet contiene una fila distinta para cada orientación, no se requiere aplicar transformaciones de inversión; únicamente se seleccionarán los fotogramas correspondientes a la fila adecuada.

---

## **1. Identificación de las filas del sprite sheet**

El recurso gráfico posee cuatro filas, cada una representando una orientación:

| Fila | Acción / Orientación               |
| ---- | ---------------------------------- |
| 0    | Vuelo visto desde arriba (ascenso) |
| 1    | Vuelo hacia la derecha             |
| 2    | Vuelo visto desde abajo (descenso) |
| 3    | Vuelo hacia la izquierda           |

Cada fila contiene tres columnas con los fotogramas de la animación.

---

## **2. Preparación de las listas de animación por dirección**

Se construyen cuatro listas independientes, una por cada dirección del movimiento:

```python
dragon_up = [get_frame(0, c) for c in range(cols)]
dragon_right = [get_frame(1, c) for c in range(cols)]
dragon_down = [get_frame(2, c) for c in range(cols)]
dragon_left = [get_frame(3, c) for c in range(cols)]
```

Se define también el estado actual de dirección:

```python
direccion_actual = "right"
dragon_index = 0
dragon_fps = 10
dragon_timer = pygame.time.get_ticks()
```

---

## **3. Actualización automática de la dirección según el teclado**

Dependiendo de qué tecla presione el usuario, el sistema cambia la orientación activa del dragón.

```python
teclas = pygame.key.get_pressed()
velocidad_dragon = 5

# Movimiento horizontal y vertical
if teclas[pygame.K_UP]:
    dragon_y -= velocidad_dragon
    direccion_actual = "up"

elif teclas[pygame.K_DOWN]:
    dragon_y += velocidad_dragon
    direccion_actual = "down"

elif teclas[pygame.K_LEFT]:
    dragon_x -= velocidad_dragon
    direccion_actual = "left"

elif teclas[pygame.K_RIGHT]:
    dragon_x += velocidad_dragon
    direccion_actual = "right"
```

El bloque mantiene siempre la dirección correcta según la última tecla activa.

---

## **4. Selección del conjunto de fotogramas adecuado**

Una vez definida la dirección actual, se selecciona la lista correspondiente:

```python
if direccion_actual == "up":
    frames = dragon_up
elif direccion_actual == "down":
    frames = dragon_down
elif direccion_actual == "left":
    frames = dragon_left
else:
    frames = dragon_right
```

---

## **5. Reproducción de la animación en la dirección apropiada**

La animación se actualiza de forma uniforme:

```python
if pygame.time.get_ticks() - dragon_timer > 1000 // dragon_fps:
    dragon_timer = pygame.time.get_ticks()
    dragon_index = (dragon_index + 1) % len(frames)

frame_actual = frames[dragon_index]
pantalla.blit(frame_actual, (dragon_x, dragon_y))
```

---

## **6. Integración dentro del bucle principal**

Este fragmento se coloca después del dibujo del escenario y antes del `pygame.display.update()`:

```python
# ------------------------------------
# Control direccional y animación
# ------------------------------------

teclas = pygame.key.get_pressed()
velocidad = 5

# Movimiento y actualización de dirección
if teclas[pygame.K_UP]:
    dragon_y -= velocidad
    direccion_actual = "up"

elif teclas[pygame.K_DOWN]:
    dragon_y += velocidad
    direccion_actual = "down"

elif teclas[pygame.K_LEFT]:
    dragon_x -= velocidad
    direccion_actual = "left"

elif teclas[pygame.K_RIGHT]:
    dragon_x += velocidad
    direccion_actual = "right"

# Selección de los frames
if direccion_actual == "up":
    frames = dragon_up
elif direccion_actual == "down":
    frames = dragon_down
elif direccion_actual == "left":
    frames = dragon_left
else:
    frames = dragon_right

# Animación
if pygame.time.get_ticks() - dragon_timer > 1000 // dragon_fps:
    dragon_timer = pygame.time.get_ticks()
    dragon_index = (dragon_index + 1) % len(frames)

pantalla.blit(frames[dragon_index], (dragon_x, dragon_y))
```

---

## **7. Actividad de comprobación**

El estudiante deberá realizar lo siguiente:

1. Explicar cómo se utiliza la fila del sprite sheet para determinar la animación de cada dirección.
2. Describir qué ocurriría si no se asignara `direccion_actual` después de cada movimiento.
3. Añadir una condición para que, si el dragón permanece sin movimiento, utilice una animación diferente (por ejemplo, el primer fotograma de cada fila).
4. Ajustar la velocidad de animación independientemente para cada dirección y analizar su efecto visual.

---




