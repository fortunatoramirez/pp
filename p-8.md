# **PRÁCTICA 8 – Introducción a los Gráficos con Pygame**

**Movimiento, Renderizado, Colisiones y Mecánicas Básicas de Juego**

---

## **1) Objetivo General**

Que el estudiante dé su primer paso formal hacia la programación de videojuegos usando Python y Pygame, comprendiendo cómo crear una ventana gráfica, dibujar objetos, moverlos con teclado en tiempo real, detectar colisiones y construir la estructura base de un juego 2D.

---

## **2) Competencias Desarrolladas**

Al finalizar esta práctica, el alumno será capaz de:

* Crear una ventana gráfica con Pygame.
* Implementar un bucle de juego (Game Loop).
* Dibujar figuras básicas (rectángulos, elementos).
* Capturar eventos del teclado en tiempo real.
* Implementar colisiones básicas.
* Administrar listas para manejar múltiples objetos.
* Agregar enemigos, ítems, HUD, vidas y condición de victoria/derrota.
* Usar árboles de decisión simples para cambiar la dificultad.

---

## **3) Requisitos Previos**

El alumno deberá dominar:

* Variables
* Tipos de datos (enteros, tuplas, listas)
* Condicionales **if / elif / else**
* Ciclos **while** y **for**
* Funciones
* Lógica básica de movimiento en consola
* Concepto de bucle principal en un juego

Instalar Pygame:

```bash
pip install pygame
```

---

# **4) DESARROLLO DE LA PRÁCTICA POR BLOQUES**

Cada bloque añade algo nuevo.
El objetivo es que el estudiante analice, copie, entienda y sume el bloque al código anterior para ir construyendo el juego completo.

---

# **BLOQUE 1 – Crear ventana y fondo**

### **Objetivo del bloque**

Aprender a iniciar Pygame, crear una ventana y llenar el fondo con un color.

### **Teoría**

Todo programa de Pygame requiere:

* `pygame.init()` → Activa el motor.
* `pygame.display.set_mode()` → Crea la ventana.
* Game loop → Actualiza pantalla cada cuadro.

### **Código del Bloque 1**

```python
import pygame
pygame.init()

ANCHO = 640
ALTO = 480

screen = pygame.display.set_mode((ANCHO, ALTO))
pygame.display.set_caption("Práctica 8 – Bloque 1")

running = True
while running:
    for event in pygame.event.get():
        if event.type == pygame.QUIT:
            running = False

    screen.fill((30, 30, 30))  # fondo gris

    pygame.display.flip()

pygame.quit()
```

---

# **BLOQUE 2 – Dibujar un jugador (rectángulo)**

### **Objetivo del bloque**

Representar un objeto en pantalla mediante coordenadas.

### **Teoría**

En 2D, un jugador puede ser simplemente un rectángulo:

```python
pygame.draw.rect(screen, color, (x, y, ancho, alto))
```

### **Código del Bloque 2**

```python
# NUEVO EN ESTE BLOQUE
player_x = 300
player_y = 200
PLAYER_ANCHO = 40
PLAYER_ALTO = 40

pygame.draw.rect(screen, (200, 50, 50), (player_x, player_y, PLAYER_ANCHO, PLAYER_ALTO))
```

---

# **BLOQUE 3 – Movimiento del jugador con teclado**

### **Objetivo del bloque**

Mover el personaje con las flechas del teclado en tiempo real.

### **Teoría**

Pygame permite consultar el estado del teclado:

```python
keys = pygame.key.get_pressed()
if keys[pygame.K_LEFT]:
    x -= velocidad
```

### **Código del Bloque 3**

```python
VEL = 5
keys = pygame.key.get_pressed()

if keys[pygame.K_LEFT]:
    player_x -= VEL
if keys[pygame.K_RIGHT]:
    player_x += VEL
if keys[pygame.K_UP]:
    player_y -= VEL
if keys[pygame.K_DOWN]:
    player_y += VEL
```

---

# **BLOQUE 4 – Colisiones con paredes**

### **Objetivo del bloque**

Evitar que el jugador salga de la pantalla.

### **Código del Bloque 4**

```python
if keys[pygame.K_LEFT] and player_x > 0:
    player_x -= VEL
if keys[pygame.K_RIGHT] and player_x < ANCHO - PLAYER_ANCHO:
    player_x += VEL
if keys[pygame.K_UP] and player_y > 0:
    player_y -= VEL
if keys[pygame.K_DOWN] and player_y < ALTO - PLAYER_ALTO:
    player_y += VEL
```

---

# **BLOQUE 5 – Ítems recolectables**

### **Objetivo del bloque**

Crear ítems que el jugador pueda recoger.
Aprender a usar listas y colisiones con `pygame.Rect`.

### **Teoría**

* Cada ítem = un rectángulo.
* Colisión:

  ```python
  if rect1.colliderect(rect2):
  ```

### **Código del Bloque 5**

```python
items = [
    pygame.Rect(100, 100, 20, 20),
    pygame.Rect(500, 300, 20, 20),
    pygame.Rect(200, 350, 20, 20),
]

player_rect = pygame.Rect(player_x, player_y, PLAYER_ANCHO, PLAYER_ALTO)

for item in items[:]:
    if player_rect.colliderect(item):
        items.remove(item)
        score += 10
```

---

# **BLOQUE 6 – Enemigo que se mueve automáticamente**

### **Objetivo del bloque**

Agregar un enemigo que se desplaza solo y genera peligro.

### **Código del Bloque 6**

```python
enemy_x = 50
enemy_y = 150
enemy_vel = 4

enemy_x += enemy_vel
if enemy_x <= 0 or enemy_x >= ANCHO - 40:
    enemy_vel *= -1

enemy_rect = pygame.Rect(enemy_x, enemy_y, 40, 40)
```

---

# **BLOQUE 7 – HUD (vidas, puntaje)**

### **Objetivo del bloque**

Mostrar información en pantalla como texto.

### **Código del Bloque 7**

```python
font = pygame.font.SysFont(None, 32)

def draw_text(txt, x, y, color=(255,255,255)):
    img = font.render(txt, True, color)
    screen.blit(img, (x, y))

draw_text(f"Vidas: {vidas}", 10, 10)
draw_text(f"Score: {score}", 10, 40)
```

---

# **BLOQUE 8 – Árbol de decisiones de dificultad**

### **Objetivo del bloque**

Modificar el comportamiento del enemigo según el puntaje.

### **Código del Bloque 8**

```python
if score < 30:
    enemy_vel = 3
elif score < 60:
    enemy_vel = 5
else:
    enemy_vel = 7
```

---

# **BLOQUE 9 – Condiciones de victoria y derrota**

### **Objetivo del bloque**

Finalizar el juego según el progreso.

### **Código del Bloque 9**

```python
if vidas <= 0:
    print("Game Over")

if len(items) == 0:
    print("¡Ganaste!")
```

---

# **BLOQUE FINAL – Código completo del juego**

Al final de la práctica, deben unir todo correctamente.
Este es el código completo ya integrado:

```python
###############################################################
# PRÁCTICA 8 – INTRODUCCIÓN A PYGAME
# Juego completo integrando todos los bloques:
# - Ventana y fondo
# - Jugador
# - Movimiento con teclado
# - Colisiones con paredes
# - Ítems recolectables
# - Enemigo
# - Árbol de decisiones
# - HUD y condiciones de victoria/derrota
###############################################################

import pygame
import random

pygame.init()

# --------------------------
# CONFIGURACIÓN GENERAL
# --------------------------
ANCHO = 640
ALTO = 480
FPS = 60

screen = pygame.display.set_mode((ANCHO, ALTO))
pygame.display.set_caption("Práctica 7 - Juego Completo")

clock = pygame.time.Clock()

# --------------------------
# JUGADOR
# --------------------------
PLAYER_ANCHO = 40
PLAYER_ALTO = 40
player_x = ANCHO // 2
player_y = ALTO // 2
VEL = 5
player_color = (200, 50, 50)
vidas = 3
score = 0

# --------------------------
# ÍTEMS (RECOLECTABLES)
# --------------------------
items = []
for i in range(5):
    ix = random.randint(40, ANCHO - 60)
    iy = random.randint(40, ALTO - 60)
    items.append(pygame.Rect(ix, iy, 20, 20))

item_color = (255, 255, 0)

# --------------------------
# ENEMIGO
# --------------------------
enemy_x = 50
enemy_y = 150
ENEMY_ANCHO = 40
ENEMY_ALTO = 40
enemy_vel = 3
enemy_color = (50, 150, 255)

# --------------------------
# HUD – FUENTE
# --------------------------
font = pygame.font.SysFont(None, 32)

# --------------------------
# FUNCIÓN PARA MOSTRAR TEXTO
# --------------------------
def draw_text(texto, x, y, color=(255,255,255)):
    img = font.render(texto, True, color)
    screen.blit(img, (x, y))


# --------------------------
# BUCLE PRINCIPAL
# --------------------------
running = True
while running:

    clock.tick(FPS)

    # EVENTOS
    for event in pygame.event.get():
        if event.type == pygame.QUIT:
            running = False

    # LEER TECLADO
    keys = pygame.key.get_pressed()

    # Movimiento del jugador con límites
    if keys[pygame.K_LEFT] and player_x > 0:
        player_x -= VEL
    if keys[pygame.K_RIGHT] and player_x < ANCHO - PLAYER_ANCHO:
        player_x += VEL
    if keys[pygame.K_UP] and player_y > 0:
        player_y -= VEL
    if keys[pygame.K_DOWN] and player_y < ALTO - PLAYER_ALTO:
        player_y += VEL

    # RECTÁNGULO DEL JUGADOR
    player_rect = pygame.Rect(player_x, player_y, PLAYER_ANCHO, PLAYER_ALTO)

    # --------------------------
    # ENEMIGO: movimiento automático
    # --------------------------
    enemy_x += enemy_vel
    if enemy_x <= 0 or enemy_x >= ANCHO - ENEMY_ANCHO:
        enemy_vel *= -1

    enemy_rect = pygame.Rect(enemy_x, enemy_y, ENEMY_ANCHO, ENEMY_ALTO)

    # --------------------------
    # COLISIONES: jugador–ítems
    # --------------------------
    for item in items[:]:
        if player_rect.colliderect(item):
            items.remove(item)
            score += 10

    # --------------------------
    # COLISIÓN: jugador–enemigo
    # --------------------------
    if player_rect.colliderect(enemy_rect):
        vidas -= 1
        player_x = ANCHO // 2
        player_y = ALTO // 2

    # --------------------------
    # ÁRBOL DE DECISIONES (dificultad)
    # --------------------------
    if score < 30:
        current_enemy_vel = 3
    elif score < 60:
        current_enemy_vel = 5
    else:
        current_enemy_vel = 7

    # actualizamos velocidad real
    enemy_vel = current_enemy_vel if enemy_vel > 0 else -current_enemy_vel

    # --------------------------
    # CONDICIONES DE VICTORIA / DERROTA
    # --------------------------
    if vidas <= 0:
        screen.fill((0,0,0))
        draw_text("GAME OVER", ANCHO//2 - 80, ALTO//2 - 20, (255,50,50))
        pygame.display.flip()
        pygame.time.wait(2000)
        break

    if len(items) == 0:
        screen.fill((0,0,0))
        draw_text("¡GANASTE!", ANCHO//2 - 80, ALTO//2 - 20, (50,255,50))
        pygame.display.flip()
        pygame.time.wait(2000)
        break

    # --------------------------
    # RENDER DE LA ESCENA
    # --------------------------
    screen.fill((30, 30, 30))

    # Dibujar jugador
    pygame.draw.rect(screen, player_color, player_rect)

    # Ítems
    for item in items:
        pygame.draw.rect(screen, item_color, item)

    # Enemigo
    pygame.draw.rect(screen, enemy_color, enemy_rect)

    # HUD
    draw_text(f"Vidas: {vidas}", 10, 10)
    draw_text(f"Score: {score}", 10, 40)

    pygame.display.flip()


pygame.quit()

```

---

# **5) Actividad Final**

El alumno deberá entregar un mini-juego donde:

1. El jugador se mueve con el teclado.
2. Recoge ítems.
3. Evita un enemigo.
4. Tiene vidas y puntaje.
5. Existe condición de victoria o derrota.
6. Hay un árbol de decisiones que modifica velocidad/dificultad.
7. El juego corre fluido en Pygame.

Debe entregar:

* Archivo .py
* Capturas o video de su ejecución
* Explicación breve del árbol de decisiones

