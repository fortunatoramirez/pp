# Práctica 6 — Render 1D → 2D

## Objetivo

Comprender paso a paso cómo “pintar” un objeto en consola y moverlo: primero en **una dimensión (1D)** y luego en **dos dimensiones (2D)**, con colisiones simples y un **hueco** en la pared.

---

## BLOQUE 0 — Un solo carácter en pantalla (la idea de “render”)

**Teoría (micro):** “Renderizar” aquí significa **imprimir texto** que representa el juego. Empezamos con un único carácter.

```python
# PRÁCTICA 6 - BLOQUE 0
# "Render" atómico: un solo carácter

print('@')  # nuestro jugador
```

---

## BLOQUE 1 — Línea 1D con el jugador en una posición (sin loops)

**Teoría:** Una línea es un string. Si el jugador está en `px`, la línea es:
`" " * px  +  "@"  +  " " * (WIDTH-1-px)`

```python
# PRÁCTICA 6 - BLOQUE 1
# Línea 1D: mover el jugador con un índice (sin loops)

WIDTH = 20
px = 5  # posición horizontal

def render_line(width, px):
    # Construye: espacios antes + jugador + espacios después
    left  = ' ' * px
    me    = '@'
    right = ' ' * (width - 1 - px)
    return left + me + right

print(render_line(WIDTH, px))
```

---

## BLOQUE 2 — Movimiento por turnos (izquierda/derecha) con límites

**Teoría:** Leer tecla (`a`/`d`) y **actualizar** `px` con límites (0 a WIDTH-1). Volvemos a “pintar” la línea.

```python
# PRÁCTICA 6 - BLOQUE 2
# Movimiento por turnos (a/d), con límites básicos

import os

WIDTH = 20
px = 5

def clear():
    os.system('cls' if os.name == 'nt' else 'clear')

def render_line(width, px):
    return ' ' * px + '@' + ' ' * (width - 1 - px)

running = True
while running:
    clear()
    print(render_line(WIDTH, px))
    print("\n[a]=izq  [d]=der  [x]=salir")
    key = input("Tecla: ").strip().lower()

    if key == 'x':
        running = False
    elif key == 'a':
        px = max(0, px - 1)       # tope a la izquierda
    elif key == 'd':
        px = min(WIDTH - 1, px + 1)  # tope a la derecha
```

---

## BLOQUE 3 — Paredes visibles en 1D (con colisión) y “paso” central

**Teoría:** Agregamos **paredes** como `|` a los extremos, y definimos un **hueco** (paso) interno. Solo puedes cruzar por el hueco, no por pared.

```python
# PRÁCTICA 6 - BLOQUE 3
# Línea con paredes |........| y un hueco " " en el centro

import os

WIDTH = 21                 # impar para tener centro exacto
LEFT_WALL = 0
RIGHT_WALL = WIDTH - 1
HOLE_X = WIDTH // 2        # hueco en el centro

px = 5

def clear():
    os.system('cls' if os.name == 'nt' else 'clear')

def render_line_1d():
    # construimos una línea con paredes en extremos y un hueco en HOLE_X
    chars = [' '] * WIDTH
    chars[LEFT_WALL] = '|'
    chars[RIGHT_WALL] = '|'
    # si hubiera una “pared interna”, aquí la colocaríamos con otro símbolo
    # marcamos jugador (si no pisa pared)
    chars[px] = '@'
    return ''.join(chars)

def can_move(nx):
    # no permitir salir fuera de la línea
    if nx < 0 or nx > RIGHT_WALL: 
        return False
    # no permitir estar sobre las paredes extremas (excepto si justo es hueco,
    # pero el hueco está en medio, no en extremos)
    if nx == LEFT_WALL or nx == RIGHT_WALL:
        return False
    return True

running = True
while running:
    clear()
    print(render_line_1d())
    print(f"\nHueco en x={HOLE_X}. Cruza por ahí. [a/d] moverse, [x] salir")
    key = input("Tecla: ").strip().lower()

    if key == 'x':
        running = False
    elif key in ('a', 'd'):
        dx = -1 if key == 'a' else 1
        nx = px + dx

        # si el siguiente es pared extrema, bloquea
        if can_move(nx):
            px = nx
```

> Nota: Aquí el **hueco** no está realmente en una pared porque la pared está en los extremos; el concepto de “paso” lo formalizamos en 2D (siguiente bloque). Este paso 1D es para fijar la idea de “límites visibles”.

---

## BLOQUE 4 — Salto a 2D sin bucles anidados: tablero por **líneas preconstruidas**

**Teoría:** Un “tablero” es una **lista de strings** (cada string = una fila).

* Top y bottom son paredes `#...#`.
* Las filas del medio son `#   ...   #`.
* **Sin bucles anidados:** construimos top, middle y bottom; creamos la lista de líneas con multiplicación de listas; y **reemplazamos** la fila del jugador para “pintarlo”.

```python
# PRÁCTICA 6 - BLOQUE 4
# Tablero 2D sin bucles anidados: lista de líneas, reemplazando solo la fila del jugador

import os

WIDTH, HEIGHT = 20, 10
PLAYER = '@'

# Paredes
TOP    = '#' * WIDTH
BOTTOM = '#' * WIDTH
MIDDLE = '#' + ' ' * (WIDTH - 2) + '#'

# Jugador
px, py = WIDTH // 2, HEIGHT // 2

def clear():
    os.system('cls' if os.name == 'nt' else 'clear')

def put_char(line, x, ch):
    # reemplaza el caracter en x por ch
    return line[:x] + ch + line[x+1:]

def render_board(px, py):
    # 1) Construye las filas: top, (HEIGHT-2) middle, bottom
    lines = [TOP] + [MIDDLE] * (HEIGHT - 2) + [BOTTOM]
    # 2) Dibuja jugador solo en la fila py (sin bucles anidados)
    if 0 < py < HEIGHT - 1:
        line = lines[py]
        if 0 < px < WIDTH - 1:
            line = put_char(line, px, PLAYER)
        lines[py] = line
    # 3) Imprime
    clear()
    print('\n'.join(lines))

render_board(px, py)
```

---

## BLOQUE 5 — Movimiento 2D por turnos (WASD), con colisión contra paredes

**Teoría:** Antes de mover, calculamos `(nx, ny)` y **validamos**: no se puede pisar paredes (`x==0` o `x==WIDTH-1` o `y==0` o `y==HEIGHT-1`).

```python
# PRÁCTICA 6 - BLOQUE 5
# Movimiento 2D por turnos con colisión contra paredes

import os

WIDTH, HEIGHT = 20, 10
PLAYER = '@'
TOP    = '#' * WIDTH
BOTTOM = '#' * WIDTH
MIDDLE = '#' + ' ' * (WIDTH - 2) + '#'

px, py = WIDTH // 2, HEIGHT // 2

def clear():
    os.system('cls' if os.name == 'nt' else 'clear')

def put_char(line, x, ch):
    return line[:x] + ch + line[x+1:]

def render_board(px, py):
    lines = [TOP] + [MIDDLE] * (HEIGHT - 2) + [BOTTOM]
    if 0 < py < HEIGHT - 1 and 0 < px < WIDTH - 1:
        lines[py] = put_char(lines[py], px, PLAYER)
    clear()
    print('\n'.join(lines))

def can_move(nx, ny):
    # bloquea paredes
    if nx <= 0 or nx >= WIDTH - 1:  return False
    if ny <= 0 or ny >= HEIGHT - 1: return False
    return True

running = True
while running:
    render_board(px, py)
    print("\nWASD moverse | X salir")
    key = input("Tecla: ").strip().lower()

    if key == 'x':
        running = False
    else:
        dx = (key == 'd') - (key == 'a')  # d=1, a=0 → 1 ; a=1, d=0 → -1 ; otras 0
        dy = (key == 's') - (key == 'w')
        nx, ny = px + dx, py + dy
        if dx != 0 or dy != 0:
            if can_move(nx, ny):
                px, py = nx, ny
```

---

## BLOQUE 6 — “Hueco” real en una pared (paso permitido)

**Teoría:** Hacemos un **hueco** en la pared derecha. Para eso, **modificamos la línea** de la fila `HOLE_Y` y ponemos un espacio en `x = WIDTH-1`. Luego, en `can_move`, permitimos que `(nx, ny)` cruce por ese hueco.

```python
# PRÁCTICA 6 - BLOQUE 6
# Hueco en pared derecha: se puede “salir” solo por ese punto

import os

WIDTH, HEIGHT = 24, 12
PLAYER = '@'
TOP    = '#' * WIDTH
BOTTOM = '#' * WIDTH
MIDDLE = '#' + ' ' * (WIDTH - 2) + '#'

# Hueco en pared derecha (x = WIDTH-1, y = HOLE_Y)
HOLE_Y = HEIGHT // 2

px, py = WIDTH // 2, HEIGHT // 2

def clear():
    os.system('cls' if os.name == 'nt' else 'clear')

def put_char(line, x, ch):
    return line[:x] + ch + line[x+1:]

def build_lines_with_hole():
    lines = [TOP] + [MIDDLE] * (HEIGHT - 2) + [BOTTOM]
    # convertir la fila HOLE_Y en lista mutable y abrir hueco a la derecha
    if 0 < HOLE_Y < HEIGHT - 1:
        line = lines[HOLE_Y]
        # pared derecha está en x = WIDTH-1, la “abrimos” a espacio
        line = put_char(line, WIDTH - 1, ' ')
        lines[HOLE_Y] = line
    return lines

def render_board(px, py, lines):
    if 0 <= py < HEIGHT and 0 <= px < WIDTH:
        if 0 < py < HEIGHT - 1:  # evita pintar sobre top/bottom
            line = lines[py]
            # si el borde derecho está abierto en esta fila, igual podemos pintar al jugador
            if 0 <= px < WIDTH:
                line = put_char(line, px, PLAYER)
            lines[py] = line
    clear()
    print('\n'.join(lines))

def is_wall(x, y):
    # Paredes: top/bottom siempre pared
    if y == 0 or y == HEIGHT - 1: return True
    # izquierda pared
    if x == 0: return True
    # derecha pared EXCEPTO en el hueco (x=WIDTH-1, y=HOLE_Y)
    if x == WIDTH - 1 and y != HOLE_Y: return True
    return False

def can_move(nx, ny):
    # dentro de límites globales
    if nx < 0 or nx >= WIDTH or ny < 0 or ny >= HEIGHT:
        return False
    # permitir paso por hueco, bloquear cualquier otra pared
    return not is_wall(nx, ny)

running = True
while running:
    lines = build_lines_with_hole()
    render_board(px, py, lines)
    print("\nWASD moverse | X salir | Objetivo: sal por el hueco de la derecha")
    key = input("Tecla: ").strip().lower()

    if key == 'x':
        running = False
    else:
        dx = (key == 'd') - (key == 'a')
        dy = (key == 's') - (key == 'w')
        nx, ny = px + dx, py + dy
        if dx != 0 or dy != 0:
            if can_move(nx, ny):
                px, py = nx, ny
                # Si “sales” por el hueco (estás en x=WIDTH-1 y y=HOLE_Y), mensaje y terminar
                if px == WIDTH - 1 and py == HOLE_Y:
                    lines = build_lines_with_hole()
                    render_board(px, py, lines)
                    print("\n¡Saliste por el hueco! ✨")
                    input("Enter para terminar...")
                    break
```

---

## Actividad breve

1. Mueve el **hueco** al **borde superior**, centrado. Ajusta la lógica para permitir salir por ahí.
2. Crea una **“pared interna”** horizontal (solo una línea de `#`) en el medio, con un **hueco interno** para cruzar. (Pista: toma `MIDDLE` y construye una variante para esa fila; no necesitas bucles anidados).
3. Cambia el símbolo del jugador por otro (ej. `'A'`) y agrega una **variable** `player_char` para que sea configurable.

---
