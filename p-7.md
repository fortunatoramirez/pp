# Práctica – Mini-mundo en consola (Python, Windows)

---
> **Controles (desde ahora y a lo largo de la práctica)**
>
> * `W/A/S/D`: mover al jugador
> * `Q`: salir del juego
> * En bloques posteriores: `I` (inventario), `G` (guardar), `C` (cargar), etc.
---

## Bloque 0 — Código base (referencia del profesor)

Tu código actual sirve como **punto de partida**. No lo borren: consérvenlo como “versión 0”. A partir de aquí iremos **refactorizando** sin perder funcionalidad.

---

## Bloque 1 — Encapsular el dibujo (funciones)

**Objetivo.** Introducir funciones y limpiar el “main loop”.

**Qué harás.** Separar en funciones: `gotoxy`, `limpiar()`, `dibujar_bordes()`, `dibujar_hud()`, `dibujar_juego()`.

```python
import msvcrt, sys, os

# -------- Funciones utilitarias --------
def gotoxy(x, y):
    sys.stdout.write(f"\033[{y};{x}H")
    sys.stdout.flush()

def limpiar():
    os.system('cls')

def dibujar_bordes(W=60, H=20):
    # Piso y techo
    for i in range(W):
        gotoxy(i, H)   ; print('#')
        gotoxy(i, 1)   ; print('#')
    # Paredes
    for i in range(1, H+1):
        gotoxy(0, i)   ; print('#')
        gotoxy(W, i)   ; print('#')

def dibujar_hud(vida, score):
    gotoxy(50, 2); print('Vida:', vida)
    gotoxy(50, 3); print('Score:', score)

def dibujar_juego(jugador, objetivo):
    # objetivo y jugador
    gotoxy(*objetivo); print('*')
    gotoxy(*jugador) ; print('@')

# -------- Lógica principal --------
W, H = 60, 20
jugador = (5, 5)
objetivo = (15, 10)
vida = 100
score = 0

while True:
    if msvcrt.kbhit():
        key = (msvcrt.getch()).decode().lower()
        if key == 'q':
            break
        # Movimiento simple (igual que tu base)
        x, y = jugador
        if key == 'd' and x < W-1: x += 1
        elif key == 'a' and x > 2: x -= 1
        elif key == 's' and y < H-1: y += 1
        elif key == 'w' and y > 2: y -= 1
        jugador = (x, y)

        limpiar()
        dibujar_bordes(W, H)
        dibujar_hud(vida, score)
        dibujar_juego(jugador, objetivo)

        if jugador == objetivo:
            gotoxy(3, 2); print('Objeto detectado')
```

**Mini-reto.** Cambia el símbolo del jugador a `&` y del objetivo a `+`.

---

## Bloque 2 — Mapa de movimientos con diccionario

**Objetivo.** Usar **diccionario** para mapear teclas→desplazamientos y reducir `if/elif`.

```python
MOVES = {'w': (0,-1), 's': (0,1), 'a': (-1,0), 'd': (1,0)}

# En el loop:
if key in MOVES:
    dx, dy = MOVES[key]
    x, y = jugador
    nx, ny = x + dx, y + dy
    # límites (paredes internas)
    if 2 <= nx <= 60-1 and 2 <= ny <= 20-1:
        jugador = (nx, ny)
```

**Mini-reto.** Agrega una tecla `x` que mueva al jugador en diagonal (por ejemplo, `(+1,+1)`).

---

## Bloque 3 — Múltiples objetivos con **listas de tuplas**

**Objetivo.** Representar **varios ítems** en una **lista** de **tuplas** (coordenadas). Al tocar uno, se elimina y aumenta el score.

```python
objetivos = [(15,10), (25, 7), (40, 15)]
score = 0

def dibujar_objetivos(objs):
    for pos in objs:
        gotoxy(*pos); print('*')

# En el loop, tras mover:
limpiar()
dibujar_bordes(W, H)
dibujar_hud(vida, score)
dibujar_objetivos(objetivos)
gotoxy(*jugador); print('@')

# Colisión con cualquier objetivo
if jugador in objetivos:
    objetivos.remove(jugador)
    score += 10
```

**Mini-reto.** Si ya no hay objetivos, muestra “¡Nivel completado!” en (3,2).

---

## Bloque 4 — Obstáculos con **listas** (y variante con **set**)

**Objetivo.** Introducir colisión con obstáculos. Primero con **lista** (basta para pocos), luego explicar que un **set** acelera el `in`.

```python
# Bloques sólidos
obstaculos = [(10,5),(11,5),(12,5),(13,5),(14,5),
              (30,12),(31,12),(32,12),
              (45,8),(45,9),(45,10)]

def dibujar_obstaculos(obs):
    for p in obs:
        gotoxy(*p); print('X')

# Al mover:
if key in MOVES:
    dx, dy = MOVES[key]
    x, y = jugador
    nx, ny = x + dx, y + dy
    if 2 <= nx <= W-1 and 2 <= ny <= H-1 and (nx,ny) not in obstaculos:
        jugador = (nx, ny)

# Dibujar
dibujar_obstaculos(obstaculos)
```

> **Variante (explicación corta):**
> Para muchos obstáculos, usa `obst_set = set(obstaculos)` y cambia la verificación a `(nx,ny) not in obst_set` (búsqueda **O(1)**).

**Mini-reto.** Crea una “puerta” (hueco) dentro de una pared de obstáculos y verifica que el jugador solo pasa por el hueco.

---

## Bloque 5 — HUD con **diccionario** de estado

**Objetivo.** Guardar variables de juego en un **dict** y leerlas/escribirlas consistentemente.

```python
estado = {
    'vida': 100,
    'score': 0,
    'nivel': 1
}

def dibujar_hud(estado):
    gotoxy(50, 2); print('Vida :', estado['vida'])
    gotoxy(50, 3); print('Score:', estado['score'])
    gotoxy(50, 4); print('Nivel:', estado['nivel'])
```

**Mini-reto.** Resta 1 de vida cada 30 movimientos y muestra “¡Cuidado!” cuando sea < 30.

---

## Bloque 6 — Ítems con **diccionarios** (tipo + posición)

**Objetivo.** Trabajar listas de **diccionarios**: cada ítem tendrá **tipo** y **pos**. Al recolectar, aumentará score distinto según tipo y se registrará en un **inventario** (dict).

```python
# Lista de ítems
items = [
    {'tipo': 'oro',   'pos': (18, 6), 'valor': 10, 'char': '$'},
    {'tipo': 'plata', 'pos': (28,14), 'valor': 5,  'char': '%'},
    {'tipo': 'gema',  'pos': (50,10), 'valor': 20, 'char': '&'},
]

inventario = {'oro': 0, 'plata': 0, 'gema': 0}

def dibujar_items(items):
    for it in items:
        gotoxy(*it['pos']); print(it['char'])

# Dibujo:
dibujar_items(items)

# Recolección
for it in list(items):  # copia para poder remover
    if jugador == it['pos']:
        estado['score'] += it['valor']
        inventario[it['tipo']] += 1
        items.remove(it)
```

**Mini-reto.** Muestra un panel rápido del inventario en `gotoxy(3, 2)` cuando el jugador pulse `i`.

---

## Bloque 7 — Pausar y panel (interacción de estado)

**Objetivo.** Alternar un **flag** de pausa e imprimir un **panel** (inventario y ayuda).

```python
pausado = False

def dibujar_panel(inventario):
    gotoxy(3,2);  print('=== PANEL ===       (I: cerrar)')
    gotoxy(3,3);  print('Inventario ->', inventario)
    gotoxy(3,4);  print('Controles: WASD mover, Q salir, I panel')

# En el loop:
if key == 'i':
    pausado = not pausado

limpiar()
dibujar_bordes(W, H)
dibujar_hud(estado)
dibujar_obstaculos(obstaculos)
dibujar_items(items)
gotoxy(*jugador); print('@')

if pausado:
    dibujar_panel(inventario)
    continue  # no procesar juego mientras está abierto el panel
```

**Mini-reto.** Muestra también el número de objetivos restantes.

---

## Bloque 8 — “Daño” por obstáculo peligroso (tuplas especiales)

**Objetivo.** Integrar lógica condicional con una **lista** de casillas peligrosas. Si el jugador pisa una, pierde vida.

```python
peligros = [(35, 10), (36,10), (37,10)]  # lava
def dibujar_peligros(ps):
    for p in ps:
        gotoxy(*p); print('~')  # lava

# Tras mover:
if jugador in peligros:
    estado['vida'] -= 5

# Dibujar:
dibujar_peligros(peligros)
```

**Mini-reto.** Si la vida llega a 0, mostrar “GAME OVER” y salir del bucle.

---

## Bloque 9 — Configuración centralizada (diccionario “config”)

**Objetivo.** Agrupar constantes en un **dict** para facilitar cambios.

```python
config = {
    'W': 60,
    'H': 20,
    'char_borde': '#',
    'char_player': '@'
}
# Usa config['W'] y config['H'] en vez de W, H “sueltos”
```

**Mini-reto.** Cambia solo en `config` el tamaño del mapa y revisa que todo siga funcionando.

---

## Bloque 10 — Guardar / cargar partida (JSON)

**Objetivo.** Serializar y deserializar **dicts/listas/tuplas** con `json`.

```python
import json

def guardar_partida(nombre, jugador, estado, items, inventario):
    data = {
        'jugador': {'x': jugador[0], 'y': jugador[1]},
        'estado': estado,
        'items': items,
        'inventario': inventario
    }
    with open(nombre, 'w', encoding='utf-8') as f:
        json.dump(data, f)

def cargar_partida(nombre):
    with open(nombre, 'r', encoding='utf-8') as f:
        data = json.load(f)
    jugador = (data['jugador']['x'], data['jugador']['y'])
    return jugador, data['estado'], data['items'], data['inventario']

# En el loop de teclado:
if key == 'g':
    guardar_partida('save.json', jugador, estado, items, inventario)
if key == 'c':
    jugador, estado, items, inventario = cargar_partida('save.json')
```

**Mini-reto.** Agrega manejo de errores si el archivo no existe al cargar.

---

## Bloque 11 — Misiones simples (listas + condicionales)

**Objetivo.** Crear una **lista de misiones** con estados y actualizarla al recolectar ítems.

```python
misiones = [
    {'id': 1, 'desc': 'Recolecta 2 oro',   'ok': False},
    {'id': 2, 'desc': 'Recolecta 1 gema',  'ok': False},
]

def evaluar_misiones(inventario, misiones):
    if inventario['oro'] >= 2:
        misiones[0]['ok'] = True
    if inventario['gema'] >= 1:
        misiones[1]['ok'] = True

# En cada tick:
evaluar_misiones(inventario, misiones)

def dibujar_misiones(misiones):
    y = 6
    gotoxy(50, y-1); print('Misiones:')
    for m in misiones:
        gotoxy(50, y); print(f"[{'✔' if m['ok'] else ' '}] {m['desc']}")
        y += 1
```

**Mini-reto.** Cuando todas estén completas, sube `estado['nivel']` en 1.

---

## Bloque 12 — Limpieza final y checklist

**Objetivo.** Consolidar el proyecto y repasar conceptos.

**Checklist (para entregar):**

* [ ] Mover jugador con mapa de movimientos (diccionario).
* [ ] Representar posiciones con **tuplas**.
* [ ] Manejar varios objetivos en **listas**.
* [ ] Guardar estado del juego en **diccionario**.
* [ ] Recolectar distintos ítems (lista de **diccionarios**) y actualizar **inventario**.
* [ ] Colisiones con obstáculos.
* [ ] Panel de pausa/inventario.
* [ ] Peligros que restan vida y “Game Over”.
* [ ] Config centralizada (`config`).
* [ ] Guardar/cargar partida con JSON.
* [ ] Misiones con progreso.

---

## Notas didácticas rápidas

* **Tuplas**: ideales para **coordenadas** (inmutables).
* **Listas**: colecciones ordenadas modificables (objetivos/obstáculos).
* **Diccionarios**: agrupan “propiedades” de cosas (estado del juego, ítems con tipo/valor, inventario).
* **Funciones**: separan responsabilidades (dibujo, lógica, IO).
* **Refactor**: cambia forma sin cambiar comportamiento (mejora claridad).
